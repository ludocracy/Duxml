var search_data = {"index":{"searchIndex":["duxml","add","attrnamepattern","attrvalpattern","attributesrule","change","changeattribute","changecontent","childpattern","childrenrule","contentpattern","contentrule","edit","error","grammar","history","meta","newattribute","newcontent","object","objectguts","objectinterface","pcdata","pattern","qualifyerror","remove","rule","undo","validateerror","valuerule","nokogiri","xml","document","object","regexp","string","tree","treenode","<<()","<<()","<=>()","[]()","[]()","[]=()","added()","affected_parent()","attr_name()","attr_name()","attr_name()","attr_name()","attr_name()","attr_name()","attributes()","classify()","content()","content()","content=()","content=()","date()","descended_from?()","description()","description()","description()","description()","description()","description()","description()","description()","description()","description()","description()","description()","description()","description()","description()","description()","description()","description()","description()","description()","description()","design()","dux()","each()","each()","each()","element()","error_line_no()","find()","find_child()","find_children()","get_meta_file()","grammar()","grammar()","grammar=()","history()","id()","identifier()","identifier?()","is_component?()","load()","log()","meta()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new_content()","new_content()","nmtoken()","non_compliant_change()","non_compliant_change()","object()","object()","object()","object()","old_content()","position()","qualify()","qualify()","qualify()","qualify()","qualify()","qualify()","relationship()","relationship()","relationship()","relationship()","relaxng()","relaxng()","relaxng()","relaxng()","relaxng()","remove()","remove_empty_lines!()","removed()","rename()","save()","simple_class()","statement()","subject()","subject()","subject()","text?()","text?()","to_s()","to_s()","type()","undone_change()","update()","validate()","validate()","value()","value()","violated_rule()","xml()","xml_root()"],"longSearchIndex":["duxml","duxml::add","duxml::attrnamepattern","duxml::attrvalpattern","duxml::attributesrule","duxml::change","duxml::changeattribute","duxml::changecontent","duxml::childpattern","duxml::childrenrule","duxml::contentpattern","duxml::contentrule","duxml::edit","duxml::error","duxml::grammar","duxml::history","duxml::meta","duxml::newattribute","duxml::newcontent","duxml::object","duxml::objectguts","duxml::objectinterface","duxml::pcdata","duxml::pattern","duxml::qualifyerror","duxml::remove","duxml::rule","duxml::undo","duxml::validateerror","duxml::valuerule","nokogiri","nokogiri::xml","nokogiri::xml::document","object","regexp","string","tree","tree::treenode","duxml::meta#<<()","duxml::objectinterface#<<()","duxml::pattern#<=>()","duxml::history#[]()","duxml::objectinterface#[]()","duxml::objectinterface#[]=()","duxml::add#added()","duxml::validateerror#affected_parent()","duxml::attrnamepattern#attr_name()","duxml::attrvalpattern#attr_name()","duxml::attributesrule#attr_name()","duxml::changeattribute#attr_name()","duxml::newattribute#attr_name()","duxml::valuerule#attr_name()","duxml::objectinterface#attributes()","string#classify()","duxml::objectinterface#content()","duxml::pcdata#content()","duxml::objectinterface#content=()","duxml::pcdata#content=()","duxml::change#date()","duxml::objectinterface#descended_from?()","duxml::add#description()","duxml::attrnamepattern#description()","duxml::attrvalpattern#description()","duxml::change#description()","duxml::changeattribute#description()","duxml::changecontent#description()","duxml::childpattern#description()","duxml::contentpattern#description()","duxml::grammar#description()","duxml::history#description()","duxml::newattribute#description()","duxml::newcontent#description()","duxml::objectinterface#description()","duxml::pcdata#description()","duxml::pattern#description()","duxml::qualifyerror#description()","duxml::remove#description()","duxml::rule#description()","duxml::undo#description()","duxml::validateerror#description()","duxml::valuerule#description()","duxml::meta#design()","duxml#dux()","duxml::history#each()","duxml::objectinterface#each()","tree::treenode#each()","object#element()","duxml::validateerror#error_line_no()","duxml::meta#find()","duxml::objectinterface#find_child()","duxml::objectinterface#find_children()","duxml#get_meta_file()","duxml#grammar()","duxml::meta#grammar()","duxml::meta#grammar=()","duxml::meta#history()","duxml::objectinterface#id()","regexp::identifier()","string#identifier?()","duxml::objectinterface#is_component?()","duxml#load()","duxml#log()","duxml::objectinterface#meta()","duxml::attributesrule::new()","duxml::change::new()","duxml::changeattribute::new()","duxml::changecontent::new()","duxml::childrenrule::new()","duxml::contentrule::new()","duxml::grammar::new()","duxml::history::new()","duxml::meta::new()","duxml::newattribute::new()","duxml::object::new()","duxml::pcdata::new()","duxml::pattern::new()","duxml::remove::new()","duxml::rule::new()","duxml::validateerror::new()","duxml::valuerule::new()","duxml::changecontent#new_content()","duxml::newcontent#new_content()","regexp::nmtoken()","duxml::qualifyerror#non_compliant_change()","duxml::validateerror#non_compliant_change()","duxml::attrnamepattern#object()","duxml::contentpattern#object()","duxml::pattern#object()","duxml::rule#object()","duxml::changecontent#old_content()","duxml::objectinterface#position()","duxml::attributesrule#qualify()","duxml::childrenrule#qualify()","duxml::contentrule#qualify()","duxml::grammar#qualify()","duxml::rule#qualify()","duxml::valuerule#qualify()","duxml::attrnamepattern#relationship()","duxml::attrvalpattern#relationship()","duxml::childpattern#relationship()","duxml::pattern#relationship()","duxml#relaxng()","duxml::attributesrule#relaxng()","duxml::childrenrule#relaxng()","duxml::grammar#relaxng()","duxml::valuerule#relaxng()","duxml::objectinterface#remove()","nokogiri::xml::document#remove_empty_lines!()","duxml::remove#removed()","duxml::objectinterface#rename()","duxml#save()","object#simple_class()","duxml::rule#statement()","duxml::change#subject()","duxml::pattern#subject()","duxml::rule#subject()","duxml::objectinterface#text?()","duxml::pcdata#text?()","duxml::objectinterface#to_s()","duxml::pcdata#to_s()","duxml::objectinterface#type()","duxml::undo#undone_change()","duxml::history#update()","duxml#validate()","duxml::grammar#validate()","duxml::attrvalpattern#value()","duxml::newattribute#value()","duxml::error#violated_rule()","object#xml()","duxml::objectinterface#xml_root()"],"info":[["Duxml","","Duxml.html","",""],["Duxml::Add","","Duxml/Add.html","","<p>created when an object gains a child\n"],["Duxml::AttrNamePattern","","Duxml/AttrNamePattern.html","","<p>pattern representing relationship between an object and one of its\nattributes\n"],["Duxml::AttrValPattern","","Duxml/AttrValPattern.html","","<p>pattern representing relationship between an object&#39;s attribute and its\nvalue\n"],["Duxml::AttributesRule","","Duxml/AttributesRule.html","","<p>rule that states what attribute names a given object is allowed to have\n"],["Duxml::Change","","Duxml/Change.html","","<p>do not use - only for subclassing changes represent events i.e. patterns\nwith a fixed position in time, …\n"],["Duxml::ChangeAttribute","","Duxml/ChangeAttribute.html","","<p>created when object has a given attribute and its value has been changed\n"],["Duxml::ChangeContent","","Duxml/ChangeContent.html","","<p>created when object has no XML children but has text and text has been\nchanged\n"],["Duxml::ChildPattern","","Duxml/ChildPattern.html","","<p>pattern representing relationship between an object and its child\n"],["Duxml::ChildrenRule","","Duxml/ChildrenRule.html","","<p>rule that states what children and how many a given object is allowed to\nhave\n"],["Duxml::ContentPattern","","Duxml/ContentPattern.html","","<p>pattern representing relationship between an object and its text-only child\n"],["Duxml::ContentRule","","Duxml/ContentRule.html","",""],["Duxml::Edit","","Duxml/Edit.html","","<p>do not use; for subclassing represents changes to XML not affecting tree\nstructure\n"],["Duxml::Error","","Duxml/Error.html","","<p>do not use\n"],["Duxml::Grammar","","Duxml/Grammar.html","","<p>contains Duxml::Rules and can apply them by validating XML or qualifying\nuser input reporting Duxml::Errors …\n"],["Duxml::History","","Duxml/History.html","",""],["Duxml::Meta","","Duxml/Meta.html","",""],["Duxml::NewAttribute","","Duxml/NewAttribute.html","","<p>created when object gains a new attribute\n"],["Duxml::NewContent","","Duxml/NewContent.html","","<p>created when object had no children or text and text has been added\n"],["Duxml::Object","","Duxml/Object.html","","<p>Duxml::Object is a Ruby Object combined with a Tree::TreeNode&#39;s methods\nvia subclassing With some …\n"],["Duxml::ObjectGuts","","Duxml/ObjectGuts.html","",""],["Duxml::ObjectInterface","","Duxml/ObjectInterface.html","",""],["Duxml::PCData","","Duxml/PCData.html","","<p>Duxml class for XML text nodes\n"],["Duxml::Pattern","","Duxml/Pattern.html","",""],["Duxml::QualifyError","","Duxml/QualifyError.html","","<p>created when grammar detects error from user input\n"],["Duxml::Remove","","Duxml/Remove.html","","<p>created when object loses a child\n"],["Duxml::Rule","","Duxml/Rule.html","","<p>do not use - must be subclassed!\n"],["Duxml::Undo","","Duxml/Undo.html","","<p>created when a previous change is undone\n"],["Duxml::ValidateError","","Duxml/ValidateError.html","","<p>created when grammar detects error from file\n"],["Duxml::ValueRule","","Duxml/ValueRule.html","","<p>rule that states what values a given attribute name is allowed to have\n"],["Nokogiri","","Nokogiri.html","",""],["Nokogiri::XML","","Nokogiri/XML.html","",""],["Nokogiri::XML::Document","","Nokogiri/XML/Document.html","",""],["Object","","Object.html","",""],["Regexp","","Regexp.html","",""],["String","","String.html","",""],["Tree","","Tree.html","","<p>rubytree gem bug fix; submit to project once you can replicate in test!\nprevious algorithm was: node_stack …\n"],["Tree::TreeNode","","Tree/TreeNode.html","",""],["<<","Duxml::Meta","Duxml/Meta.html#method-i-3C-3C","(obj)","<p>adding Duxml::Design or XML to Duxml::Meta will add it to object tree but\nnot to XML to retain properties …\n"],["<<","Duxml::ObjectInterface","Duxml/ObjectInterface.html#method-i-3C-3C","(obj)","<p>add a child from given object; method will attempt to coerce object into\nacceptable Duxml::Object allowable …\n"],["<=>","Duxml::Pattern","Duxml/Pattern.html#method-i-3C-3D-3E","(pattern)",""],["[]","Duxml::History","Duxml/History.html#method-i-5B-5D","(key)","<p>override #[] to return child of history\n"],["[]","Duxml::ObjectInterface","Duxml/ObjectInterface.html#method-i-5B-5D","(attr=nil)","<p>shortcut for accessing XML attributes @param attr [String|Symbol] desired\nattribute @return [String|Hash] …\n"],["[]=","Duxml::ObjectInterface","Duxml/ObjectInterface.html#method-i-5B-5D-3D","(key, val)","<p>@param key [Symbol|String] change given attribute @param val\n[Symbol|String|Fixnum|Float|Boolean] set …\n"],["added","Duxml::Add","Duxml/Add.html#method-i-added","(context_root=root)","<p>returns object that was added\n"],["affected_parent","Duxml::ValidateError","Duxml/ValidateError.html#method-i-affected_parent","()","<p>returns object that is parent of the pattern e.g. the parent of a child\nnode, the parent of the attribute, …\n"],["attr_name","Duxml::AttrNamePattern","Duxml/AttrNamePattern.html#method-i-attr_name","(context_root=nil)",""],["attr_name","Duxml::AttrValPattern","Duxml/AttrValPattern.html#method-i-attr_name","()","<p>name of the attribute whose value is the actual object of this Pattern\n"],["attr_name","Duxml::AttributesRule","Duxml/AttributesRule.html#method-i-attr_name","()","<p>@return [String] name of attribute to which this rule applies\n"],["attr_name","Duxml::ChangeAttribute","Duxml/ChangeAttribute.html#method-i-attr_name","()","<p>name of the attribute that was changed\n"],["attr_name","Duxml::NewAttribute","Duxml/NewAttribute.html#method-i-attr_name","()","<p>name of new attribute\n"],["attr_name","Duxml::ValueRule","Duxml/ValueRule.html#method-i-attr_name","()","<p>@return [String] name of the attribute to which this Rule applies\n"],["attributes","Duxml::ObjectInterface","Duxml/ObjectInterface.html#method-i-attributes","()","<p>@return [Hash] attributes as simple Hash\n"],["classify","String","String.html#method-i-classify","()",""],["content","Duxml::ObjectInterface","Duxml/ObjectInterface.html#method-i-content","()","<p>overriding TreeNode::content to point to XML head&#39;s content @return\n[String] text content whether …\n"],["content","Duxml::PCData","Duxml/PCData.html#method-i-content","()",""],["content=","Duxml::ObjectInterface","Duxml/ObjectInterface.html#method-i-content-3D","(new_content)","<p>TODO assess whether we should block user from using this to spawn children\n@param new_content [String] …\n"],["content=","Duxml::PCData","Duxml/PCData.html#method-i-content-3D","(new_text)","<p>change text value\n"],["date","Duxml::Change","Duxml/Change.html#method-i-date","()","<p>returns date and time of change\n"],["descended_from?","Duxml::ObjectInterface","Duxml/ObjectInterface.html#method-i-descended_from-3F","(idref)","<p>@param idref [String|Symbol] id of object we want to know is this\nobject&#39;s ancestor @return [Boolean] …\n"],["description","Duxml::Add","Duxml/Add.html#method-i-description","()",""],["description","Duxml::AttrNamePattern","Duxml/AttrNamePattern.html#method-i-description","()",""],["description","Duxml::AttrValPattern","Duxml/AttrValPattern.html#method-i-description","()",""],["description","Duxml::Change","Duxml/Change.html#method-i-description","()",""],["description","Duxml::ChangeAttribute","Duxml/ChangeAttribute.html#method-i-description","()",""],["description","Duxml::ChangeContent","Duxml/ChangeContent.html#method-i-description","()",""],["description","Duxml::ChildPattern","Duxml/ChildPattern.html#method-i-description","()","<p>@return [String] description of this child pattern\n"],["description","Duxml::ContentPattern","Duxml/ContentPattern.html#method-i-description","()",""],["description","Duxml::Grammar","Duxml/Grammar.html#method-i-description","()","<p>lists XML schema and content rules in order of precedence\n"],["description","Duxml::History","Duxml/History.html#method-i-description","()",""],["description","Duxml::NewAttribute","Duxml/NewAttribute.html#method-i-description","()",""],["description","Duxml::NewContent","Duxml/NewContent.html#method-i-description","()",""],["description","Duxml::ObjectInterface","Duxml/ObjectInterface.html#method-i-description","()","<p>@return [String] human-readable description of this object\n"],["description","Duxml::PCData","Duxml/PCData.html#method-i-description","()",""],["description","Duxml::Pattern","Duxml/Pattern.html#method-i-description","()",""],["description","Duxml::QualifyError","Duxml/QualifyError.html#method-i-description","()",""],["description","Duxml::Remove","Duxml/Remove.html#method-i-description","()",""],["description","Duxml::Rule","Duxml/Rule.html#method-i-description","()","<p>@return [String] default description for a Rule\n"],["description","Duxml::Undo","Duxml/Undo.html#method-i-description","()",""],["description","Duxml::ValidateError","Duxml/ValidateError.html#method-i-description","()",""],["description","Duxml::ValueRule","Duxml/ValueRule.html#method-i-description","()","<p>@return [String] description of this rule\n"],["design","Duxml::Meta","Duxml/Meta.html#method-i-design","()","<p>@return [Duxml::Object] root node of XML design content\n"],["dux","Duxml","Duxml.html#method-i-dux","(meta_xml, content_xml)","<p>@param meta_xml [Nokogiri::XML::Node] metadata XML @param content_xml\n[Nokogiri::XML::Node] content  …\n"],["each","Duxml::History","Duxml/History.html#method-i-each","(&block)","<p>override #each to return only children\n"],["each","Duxml::ObjectInterface","Duxml/ObjectInterface.html#method-i-each","(&block)","<p>TODO assess if we need this - wasn&#39;t it just for debugging? TODO\nit&#39;s possible that this was …\n"],["each","Tree::TreeNode","Tree/TreeNode.html#method-i-each","()",""],["element","Object","Object.html#method-i-element","(*args)","<p>creates instance of Nokogiri::XML::Element using args as starting values.\nfirst argument must be provided …\n"],["error_line_no","Duxml::ValidateError","Duxml/ValidateError.html#method-i-error_line_no","()","<p>returns XML file line number of error causing object (or subject if no\nobject exists)\n"],["find","Duxml::Meta","Duxml/Meta.html#method-i-find","(target)","<p>@param target [String|Symbol] name of desired Object @return\n[Duxml::Object] found Object or nil\n"],["find_child","Duxml::ObjectInterface","Duxml/ObjectInterface.html#method-i-find_child","(child_pattern, cur_obj = nil)","<p>returns the first child matching a given pattern, which can be of types:\nFixnum - for child index String …\n"],["find_children","Duxml::ObjectInterface","Duxml/ObjectInterface.html#method-i-find_children","(*types)","<p>returns an array of this object&#39;s children that match the given type(s)\ni.e. element name\n<p>@param *types …\n"],["get_meta_file","Duxml","Duxml.html#method-i-get_meta_file","()",""],["grammar","Duxml","Duxml.html#method-i-grammar","(file)","<p>@param file [String] path to file to be used as or converted to\nDuxml::Grammar @return [Duxml::Grammar] …\n"],["grammar","Duxml::Meta","Duxml/Meta.html#method-i-grammar","()","<p>@return [Duxml::Grammar]\n"],["grammar=","Duxml::Meta","Duxml/Meta.html#method-i-grammar-3D","(grammar_file)","<p>add an external grammar\n<p>@param grammar_file [String] external grammar definition file\n"],["history","Duxml::Meta","Duxml/Meta.html#method-i-history","()","<p>@return [Duxml::History]\n"],["id","Duxml::ObjectInterface","Duxml/ObjectInterface.html#method-i-id","()","<p>@return [String] id i.e. name that is unique among its siblings\n"],["identifier","Regexp","Regexp.html#method-c-identifier","()",""],["identifier?","String","String.html#method-i-identifier-3F","()",""],["is_component?","Duxml::ObjectInterface","Duxml/ObjectInterface.html#method-i-is_component-3F","()","<p>used for #respond_to?\n<p>@return [TrueClass] always returns true\n"],["load","Duxml","Duxml.html#method-i-load","(file)","<p>@param file [String] loads given file and finds or creates corresponding\nmetadata file e.g. &#39;.xml_file.duxml&#39; …\n"],["log","Duxml","Duxml.html#method-i-log","(file)","<p>@param file [String] output file path for logging human-readable validation\nerror messages\n"],["meta","Duxml::ObjectInterface","Duxml/ObjectInterface.html#method-i-meta","()","<p>@return [Duxml::Meta] root of metadata\n"],["new","Duxml::AttributesRule","Duxml/AttributesRule.html#method-c-new","(*args)","<p>can be initialized from XML Element or Ruby args args must be the name of\nthe element args must be the …\n"],["new","Duxml::Change","Duxml/Change.html#method-c-new","(*args)","<p>can be initialized from XML or from Ruby args arguments follow default\nDuxml::Pattern#initialize format …\n"],["new","Duxml::ChangeAttribute","Duxml/ChangeAttribute.html#method-c-new","(*args)",""],["new","Duxml::ChangeContent","Duxml/ChangeContent.html#method-c-new","(*args)",""],["new","Duxml::ChildrenRule","Duxml/ChildrenRule.html#method-c-new","(*args)","<p>child rules are initialized from XML or constructed from DTD element\ndeclarations e.g.\n(zeroOrMore|other-first-child)*,second-child-optional?,third-child-gt1+ …\n"],["new","Duxml::ContentRule","Duxml/ContentRule.html#method-c-new","(*args)","<p>can be initialized from XML Element or Ruby args args must be the element\nto which this rule applies …\n"],["new","Duxml::Grammar","Duxml/Grammar.html#method-c-new","(xml_node_or_file=nil)","<p>Duxml::Grammar can be initialized from XML Element or if given no\narguments,\n"],["new","Duxml::History","Duxml/History.html#method-c-new","(xml_node=nil)",""],["new","Duxml::Meta","Duxml/Meta.html#method-c-new","(xml_node=nil)","<p>TODO code looks a little dated; use #xml? ? can only be initialized from\nXML or created as anonymous …\n"],["new","Duxml::NewAttribute","Duxml/NewAttribute.html#method-c-new","(*args)","<p>TODO simplify args! currently i believe it&#39;s a hash of a hash e.g. args\n=&gt; [{subject: subj, object: …\n"],["new","Duxml::Object","Duxml/Object.html#method-c-new","(*xml_or_args)","<p>all Duxml::Objects are initialized as either XML (see\nNokogiri::XML::Node#initialize) or as arguments …\n"],["new","Duxml::PCData","Duxml/PCData.html#method-c-new","(text_node)","<p>always initialized from a string, either via interface or from XML text\nnote that the actual XML is not …\n"],["new","Duxml::Pattern","Duxml/Pattern.html#method-c-new","(*args)","<p>Duxml::Patterns can be initialized from XML or from arguments that are\ninterpreted as follows: args must …\n"],["new","Duxml::Remove","Duxml/Remove.html#method-c-new","(*args)","<p>removed child is added as child of this Remove object so it never actually\ngoes away\n"],["new","Duxml::Rule","Duxml/Rule.html#method-c-new","(*args)","<p>can be initialized from XML Element or Ruby arguments args must be the\nsubject (e.g. name of element …\n"],["new","Duxml::ValidateError","Duxml/ValidateError.html#method-c-new","(*args)","<p>validation method creates Duxml::Pattern objects to stand in for\nDuxml::Change objects (since no actual …\n"],["new","Duxml::ValueRule","Duxml/ValueRule.html#method-c-new","(*args)","<p>can be initialized from XML Element or Ruby args args must be the name of\nthe element this rule applies …\n"],["new_content","Duxml::ChangeContent","Duxml/ChangeContent.html#method-i-new_content","()","<p>content of element after change TODO have this update if subsequent change\naffects content?\n"],["new_content","Duxml::NewContent","Duxml/NewContent.html#method-i-new_content","()","<p>new content TODO update if subsequent changes to content?\n"],["nmtoken","Regexp","Regexp.html#method-c-nmtoken","()",""],["non_compliant_change","Duxml::QualifyError","Duxml/QualifyError.html#method-i-non_compliant_change","()","<p>points to change that triggered this error\n"],["non_compliant_change","Duxml::ValidateError","Duxml/ValidateError.html#method-i-non_compliant_change","()","<p>returns Duxml::Pattern that was found to be in error\n"],["object","Duxml::AttrNamePattern","Duxml/AttrNamePattern.html#method-i-object","(context_root=nil)","<p>object here represents the name of the attribute\n"],["object","Duxml::ContentPattern","Duxml/ContentPattern.html#method-i-object","()","<p>object of this pattern is the text-only content of the subject, which is\nmade the content of this Pattern …\n"],["object","Duxml::Pattern","Duxml/Pattern.html#method-i-object","(context_root=root)","<p>object of pattern; almost always the inferior object in the relationship,\ne.g. child object context_root …\n"],["object","Duxml::Rule","Duxml/Rule.html#method-i-object","()","<p>@return [NilClass, Duxml::Object] object of Rule is nil but during #qualify\n\n<pre>can be the object matching ...</pre>\n"],["old_content","Duxml::ChangeContent","Duxml/ChangeContent.html#method-i-old_content","()","<p>content of element prior to change\n"],["position","Duxml::ObjectInterface","Duxml/ObjectInterface.html#method-i-position","()","<p>@return [Fixnum] index position of this object among its siblings\n"],["qualify","Duxml::AttributesRule","Duxml/AttributesRule.html#method-i-qualify","(change_or_pattern)","<p>@param change_or_pattern [Dux::Pattern] checks an element of type\nchange_or_pattern.subject against  …\n"],["qualify","Duxml::ChildrenRule","Duxml/ChildrenRule.html#method-i-qualify","(change_or_pattern)","<p>@param change_or_pattern [Duxml::Pattern, Duxml::Change] to be evaluated to\nsee if it follows this rule …\n"],["qualify","Duxml::ContentRule","Duxml/ContentRule.html#method-i-qualify","(change_or_pattern)","<p>applies Regexp statement to text content of this node; returns false if\ncontent has XML\n"],["qualify","Duxml::Grammar","Duxml/Grammar.html#method-i-qualify","(change_or_pattern)","<p>applies applicable rule type and subject to a given change or pattern and\ngenerates errors when disqualified …\n"],["qualify","Duxml::Rule","Duxml/Rule.html#method-i-qualify","(change_or_pattern)","<p>Duxml::Rule&#39;s #qualify is only used to report errors found by its\nsubclasses&#39; #qualify methods …\n"],["qualify","Duxml::ValueRule","Duxml/ValueRule.html#method-i-qualify","(change_or_pattern)","<p>@param change_or_pattern [Duxml::Pattern, Duxml::Change] change or pattern\nto be evaluated @return [Boolean] …\n"],["relationship","Duxml::AttrNamePattern","Duxml/AttrNamePattern.html#method-i-relationship","()",""],["relationship","Duxml::AttrValPattern","Duxml/AttrValPattern.html#method-i-relationship","()",""],["relationship","Duxml::ChildPattern","Duxml/ChildPattern.html#method-i-relationship","()","<p>@return [String] describes relationship between parent and child\n"],["relationship","Duxml::Pattern","Duxml/Pattern.html#method-i-relationship","()","<p>returns relationship description as string by subtracting super class name\n(e.g. &#39;pattern&#39; or …\n"],["relaxng","Duxml","Duxml.html#method-i-relaxng","()","<p>@return [Nokogiri::XML::RelaxNG] current metadata&#39;s grammar as a\nrelaxng file\n"],["relaxng","Duxml::AttributesRule","Duxml/AttributesRule.html#method-i-relaxng","(parent)","<p>@param parent [Nokogiri::XML::Node] should be &lt;grammar&gt; @return\n[Nokogiri::XML::Node] parent, but …\n"],["relaxng","Duxml::ChildrenRule","Duxml/ChildrenRule.html#method-i-relaxng","(parent)","<p>@param parent [Nokogiri::XML::Node] parent from RelaxNG document under\nconstruction (should be &lt;grammar/&gt;) …\n"],["relaxng","Duxml::Grammar","Duxml/Grammar.html#method-i-relaxng","(*args)","<p>@param *args [nil] @return [Nokogiri::XML::RelaxNG] RelaxNG schema object\n"],["relaxng","Duxml::ValueRule","Duxml/ValueRule.html#method-i-relaxng","(parent)","<p>@param [Nokogiri::XML::Node] parent node in RelaxNG document, NOT this\nRule&#39;s document @return [Nokogiri::XML::Node] …\n"],["remove","Duxml::ObjectInterface","Duxml/ObjectInterface.html#method-i-remove","(child_or_id)","<p>removes a child matching the given child or id, returning self if\nsuccessful, nil if not @param child_or_id …\n"],["remove_empty_lines!","Nokogiri::XML::Document","Nokogiri/XML/Document.html#method-i-remove_empty_lines-21","()","<p>exists purely to clean up generated output\n"],["removed","Duxml::Remove","Duxml/Remove.html#method-i-removed","()","<p>returns removed object\n"],["rename","Duxml::ObjectInterface","Duxml/ObjectInterface.html#method-i-rename","(new_id)","<p>TODO assess whether we really need this method it appears to have some use\nif there is an ID collision …\n"],["save","Duxml","Duxml.html#method-i-save","(file = current_file)","<p>@param file [String] saves current content XML to given file path\n(Duxml@current_file by default)\n"],["simple_class","Object","Object.html#method-i-simple_class","()","<p>shortcut for turning object&#39;s class name into snake_case string\n"],["statement","Duxml::Rule","Duxml/Rule.html#method-i-statement","()","<p>@return [String] DTD or Ruby code statement that embodies this Rule\n"],["subject","Duxml::Change","Duxml/Change.html#method-i-subject","(context_dux=nil)","<p>change subject is always an object\n"],["subject","Duxml::Pattern","Duxml/Pattern.html#method-i-subject","(context_root=root)","<p>subject of pattern; almost always the superior object in the relationship,\ne.g. parent object\n"],["subject","Duxml::Rule","Duxml/Rule.html#method-i-subject","()","<p>subject of Rule is not an object but a type or @return [Stringaa] name of\nXML element or attribute to …\n"],["text?","Duxml::ObjectInterface","Duxml/ObjectInterface.html#method-i-text-3F","()","<p>all Duxml::Objects other than Duxml::PCData represent XML elements are are\ntherefore not text\n<p>@return …\n"],["text?","Duxml::PCData","Duxml/PCData.html#method-i-text-3F","()","<p>this is a text node\n"],["to_s","Duxml::ObjectInterface","Duxml/ObjectInterface.html#method-i-to_s","()","<p>returns this object as a string representation of its XML in memory; note\nthat this differs XML on file …\n"],["to_s","Duxml::PCData","Duxml/PCData.html#method-i-to_s","()","<p>dissolves object into String\n"],["type","Duxml::ObjectInterface","Duxml/ObjectInterface.html#method-i-type","()","<p>@return [String] type of object i.e. the xml element&#39;s name\n"],["undone_change","Duxml::Undo","Duxml/Undo.html#method-i-undone_change","()","<p>returns previous change instance that was undone\n"],["update","Duxml::History","Duxml/History.html#method-i-update","(type, change_hash)","<p>receives reports from interface of changes or from Duxml::Rule violations\n"],["validate","Duxml","Duxml.html#method-i-validate","(file=nil)","<p>@param file [String] path of XML file to be validated @return [Boolean]\nwhether file passed validation …\n"],["validate","Duxml::Grammar","Duxml/Grammar.html#method-i-validate","(comp)","<p>applies grammar rules to all relationships of the given object\n"],["value","Duxml::AttrValPattern","Duxml/AttrValPattern.html#method-i-value","(meta=root)","<p>current value of this attribute\n"],["value","Duxml::NewAttribute","Duxml/NewAttribute.html#method-i-value","(meta)","<p>value of the new attribute\n"],["violated_rule","Duxml::Error","Duxml/Error.html#method-i-violated_rule","()","<p>returns rule from Grammar that found this Error\n"],["xml","Object","Object.html#method-i-xml","()","<p>shortcut for turning any string-like object or class into XML extension of\nModule::Object that can turn …\n"],["xml_root","Duxml::ObjectInterface","Duxml/ObjectInterface.html#method-i-xml_root","()","<p>@return [Nokogiri::XML::Element] root element of this XML document\n"]]}}